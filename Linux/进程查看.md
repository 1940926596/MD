# Linux进程

## 查看进程

你可以使用以下命令来查看 Linux 系统的进程情况：

1. `top` 命令：该命令可以实时显示系统的进程信息，包括进程 ID、CPU 占用率、内存占用率、运行时间等。运行 `top` 命令后，按下键盘上的 `q` 键可以退出。

2. `ps` 命令：该命令用于查看当前正在运行的进程。以下是几个常用的 `ps` 命令选项：
   - `ps aux`：显示所有用户的所有进程信息。
   - `ps -ef`：显示所有进程信息，包括命令行参数。
   - `ps -eLf`：显示详细的进程线程信息。

3. `htop` 命令：类似于 `top` 命令，但提供了更多的交互式功能和可视化界面。你可以使用包管理器安装 `htop`，如 `apt`、`yum` 或 `dnf`。

4. `pstree` 命令：该命令以树形结构显示进程之间的父子关系。

这些命令可以帮助你查看系统中正在运行的进程以及它们的状态、资源占用情况等。根据你的需求选择合适的命令进行使用。

## 进程占用的端口号

要查看进程占用的端口号，你可以使用以下命令：

1. `netstat` 命令：`netstat` 命令可以显示网络连接、路由表和网络接口等信息，包括进程占用的端口号。以下是几个常用的 `netstat` 命令选项：
   - `netstat -tuln`：显示当前监听的 TCP 和 UDP 端口。
   - `netstat -tuln | grep <进程ID>`：过滤显示指定进程ID所占用的端口。
   - `netstat -tulnp`：显示监听端口和对应的进程名和进程ID。

2. `lsof` 命令：`lsof` 命令用于列出打开文件的进程信息，也可以用于查看进程占用的端口号。以下是示例命令：
   - `lsof -i :<端口号>`：查看指定端口号被哪个进程占用。
   - `lsof -i -P`：显示所有网络连接，包括进程名和端口号。

3. `ss` 命令：`ss` 命令是更快速和更强大的替代 `netstat` 命令，也可以用于查看进程占用的端口号。以下是示例命令：
   - `ss -tuln`：显示当前监听的 TCP 和 UDP 端口。
   - `ss -tulnp`：显示监听端口和对应的进程名和进程ID。

使用上述命令之一，你可以获取进程占用的端口号以及与之关联的进程信息。记得在执行命令时使用适当的权限（如使用 `sudo`）以查看所有进程的信息。

## Linux 中与线程相关的命令及 `lsof` 的含义

在 Linux 中，“线程”通常是进程的一部分，Linux 使用轻量级进程（Lightweight Process, LWP）来实现线程。查看和管理线程通常通过与进程相关的命令完成。以下是与线程相关的常用 Linux 命令

### 与线程相关的常用 Linux 命令

以下是一些用于查看或管理线程（或与线程相关的进程信息）的命令：

- **`ps`（Process Status）**：
  - **功能**：列出进程信息，可用于查看线程。
  - **线程相关选项**：
    - `-L`：显示进程中的线程（LWP）信息。
    - `-m`：显示线程（与 `-L` 类似，但格式不同）。
    - `-p <PID>`：指定进程 ID 查看特定进程的线程。
    - `-T`：显示进程的所有线程（包括线程 ID，即 SPID）。
  - **示例**：
    ```
    ps -eL | grep <process_name>
    ```
    显示所有线程（`-eL` 列出所有进程的线程），并过滤特定进程。
    ```
    ps -p 1234 -L
    ```
    查看 PID 为 1234 的进程中的线程信息。
    ```
    ps aux --sort=-%cpu
    ```
    按 CPU 使用率排序，间接查看高负载线程。

- **`top` 和 `htop`**：
  - **功能**：实时监控进程和线程。
  - **线程相关**：
    - `top`：按 `H` 键切换显示线程（默认显示进程）。
    - `htop`：更友好的交互界面，按 `F2` 进入设置，启用“Show threads”选项查看线程。
  - **示例**：
    ```
    top
    ```
    启动后按 `H` 查看线程。
    ```
    htop
    ```
    启动后按 `F2` 配置显示线程。

- **`pstree`**：
  - **功能**：以树状结构显示进程和线程关系。
  - **线程相关选项**：
    - `-p`：显示进程和线程的 PID。
  - **示例**：
    ```
    pstree -p <PID>
    ```
    显示指定进程的线程树。

- **`lsof`（List Open Files）**：
  - **功能**：列出进程打开的文件句柄（包括文件、套接字等），可间接用于线程分析。
  
  - **线程相关**：通过进程 ID 查看与线程相关的资源占用。
  
  - **示例**：
    ```
    lsof -p <PID>
    ```
    查看指定 PID 的进程（及其线程）打开的文件。
    ```
    lsof /path/to/directory
    ```
    检查哪些进程/线程在使用某个目录（例如，排查“Device or resource busy”问题）。
  
  - **`lsof` 的全称**：**List Open Files**（列出打开的文件）。
  
    - 在 Linux 中，“文件”不仅包括普通文件，还包括目录、套接字、管道、设备文件等。
    - `lsof` 是一个强大的工具，用于查看哪些进程（或线程）正在使用特定文件、目录或网络资源。
  
  - **常见用法**：
  
    - 查看进程打开的文件：
  
      ```
      lsof -p <PID>
      ```
  
    - 查看占用某个文件的进程：
  
      ```
      lsof /path/to/file
      ```
  
    - 查看网络连接（如端口）：
  
      ```
      lsof -i :80
      ```
  
      列出占用 80 端口的进程。
  
    - 检查目录占用：
  
      ```
      lsof +D /path/to/directory
      ```
  
      递归检查目录及其下所有文件的占用情况。
  
  - **输出字段**（部分关键字段）：
  
    - `COMMAND`：进程的命令名。
    - `PID`：进程 ID。
    - `TID`：线程 ID（如果启用了线程显示，需用 `-t` 或其他选项）。
    - `USER`：运行进程的用户。
    - `FD`：文件描述符（例如 `cwd` 表示当前工作目录，`txt` 表示可执行文件）。
    - `NAME`：文件或资源的路径/名称。
  
- **`pidstat`**（来自 sysstat 工具包）：
  - **功能**：提供进程和线程的资源使用统计（CPU、内存等）。
  - **线程相关选项**：
    - `-t`：显示线程级别的统计信息。
  - **示例**：
    ```
    pidstat -t -p <PID>
    ```
    查看指定 PID 的线程资源使用情况。
    ```
    pidstat -t
    ```
    显示所有线程的统计信息。

- **`thread apply`（在 GDB 中）**：GDB的` thread apply all bt `命令
  
  - **功能**：用于调试多线程程序。
  - **用法**：在 GDB 中运行程序后，使用 `thread apply all <command>` 对所有线程执行命令。
  - **示例**：
    ```
    gdb <program>
    (gdb) thread apply all bt
    ```
    显示所有线程的调用栈。
  
- **`/proc` 文件系统**：
  - **功能**：直接查看进程和线程的详细信息。
  - **线程相关**：线程信息存储在 `/proc/<PID>/task/` 目录下，每个子目录对应一个线程。
  - **示例**：
    ```
    ls /proc/<PID>/task
    ```
    列出 PID 为 `<PID>` 的进程的所有线程 ID。
    ```
    cat /proc/<PID>/task/<TID>/status
    ```
    查看特定线程（TID 为线程 ID）的状态。

## Windows查看进程

**查看被占用端口对应的 PID**

```shell
netstat -aon|findstr "port number"
```
**查看指定 PID 的进程**

```shell
tasklist|findstr "PID"
```

## 一个端口只能被一个进程占用吗?

在 Linux（以及大多数操作系统）中，**一个端口原则上只能被一个进程绑定（占用）**，但情况并不绝对，具体取决于上下文、协议和配置。以下是详细解答：

### 1. 基本原则：端口独占性
- **TCP 端口**：
  - 在 TCP 协议中，一个端口（例如 80 或 8080）通常只能被一个进程绑定到特定 IP 地址上。这是为了确保系统能够正确地将传入的网络连接路由到唯一的进程。
  - 例如，如果一个 Web 服务器（如 Nginx）绑定到 `0.0.0.0:80`，其他进程尝试绑定到相同的 IP 和端口（`0.0.0.0:80`）会失败，报错“Address already in use”（地址已被使用）。
  - **检查命令**：
    ```bash
    lsof -i :80
    ```
    或
    ```bash
    netstat -tulnp | grep :80
    ```
    查看哪个进程占用了 80 端口。

- **UDP 端口**：
  - UDP 端口的行为类似，但由于 UDP 是无连接协议，绑定规则稍有不同。通常，一个 UDP 端口也只能被一个进程绑定到特定 IP。

### 2. 例外情况：端口可以被多个进程“共享”
尽管端口通常是独占的，以下几种情况允许多个进程与同一端口关联：

- **SO_REUSEADDR 选项**：
  - 进程可以通过设置 `SO_REUSEADDR` 套接字选项来允许多个进程绑定到同一端口（通常用于 TCP 或 UDP）。
  - **场景**：
    - 开发测试中，多个实例绑定同一端口（例如调试时）。
    - 负载均衡场景，多个子进程（如 Nginx 的 worker 进程）共享同一端口。
  - **限制**：所有绑定同一端口的进程必须明确设置 `SO_REUSEADDR`，否则仍会报错。
  - **示例**（编程中）：
    ```c
    int opt = 1;
    setsockopt(socket_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
    bind(socket_fd, ...);
    ```

- **SO_REUSEPORT 选项（Linux 特有）**：
  - 从 Linux 内核 3.9 开始，`SO_REUSEPORT` 允许多个进程或线程完全独立地绑定到同一 IP 和端口，每个进程接收一部分流量。
  - **用途**：高性能服务器（如 Nginx、HAProxy）利用此选项实现多进程负载均衡，多个进程监听同一端口，内核负责分发连接。
  - **示例**：
    - 两个 Nginx 实例可以绑定到 `0.0.0.0:80`，内核会将请求平均分配。
  - **要求**：
    - 所有进程必须设置 `SO_REUSEPORT`。
    - 进程必须有相同的用户权限（或 root 权限）。
  - **检查**：
    ```bash
    ss -tlpn | grep :80
    ```
    可看到多个进程绑定到同一端口。

- **不同 IP 地址**：
  - 端口是与 IP 地址绑定的。如果服务器有多个 IP（如 `127.0.0.1` 和 `192.168.1.1`），不同进程可以绑定到不同 IP 的同一端口号。
  - 例如：
    - 进程 A 绑定 `127.0.0.1:8080`。
    - 进程 B 绑定 `192.168.1.1:8080`。
    - 这不会冲突，因为端口是基于 `(IP, 端口)` 对的。

- **线程共享**：
  - 同一进程内的多个线程可以共享进程绑定的端口，因为线程共享进程的网络句柄（文件描述符）。
  - 例如，一个多线程 Web 服务器（如 Apache 的 worker 模型）的主进程绑定 `80` 端口，所有线程共享此端口处理请求。

### 3. 常见错误：端口冲突
- **错误提示**：尝试绑定已被占用的端口时，通常会看到：
  ```
  bind(): Address already in use
  ```
- **排查方法**：
  1. 使用 `lsof` 或 `netstat` 检查占用端口的进程：
     ```bash
     lsof -i :80
     ```
     输出示例：
     ```
     COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
     nginx   12345 root    6u  IPv4  45678      0t0  TCP *:80 (LISTEN)
     ```
  2. 终止占用进程（如果需要）：
     ```bash
     kill -9 <PID>
     ```
  3. 或等待端口释放（某些进程可能因 TIME_WAIT 状态暂时占用端口）。

- **预防冲突**：
  - 检查端口是否被占用：
    ```bash
    netstat -tulnp | grep <port>
    ```
  - 使用 `SO_REUSEADDR` 或 `SO_REUSEPORT`（需编程支持）。
  - 选择未使用的端口（例如，动态分配高位端口 1024-65535）。

### 4. 与线程的关系
- 提到“线程命令”（结合之前的问题），需要澄清：**端口绑定是进程级别的操作**，而不是线程级别的。
  - 线程共享进程的网络套接字，因此一个进程绑定端口后，其所有线程都可以通过该端口通信。
  - 如果你想检查线程级别的资源占用，可以结合 `lsof -p <PID>` 和 `/proc/<PID>/task` 查看线程的文件描述符，但端口本身仍由进程管理。

### 5. 总结
- **默认情况**：一个端口（特定 IP 和端口组合）只能被一个进程绑定。
- **例外**：
  - 使用 `SO_REUSEADDR` 或 `SO_REUSEPORT` 允许多个进程共享端口。
  - 不同 IP 地址可以使用同一端口号。
  - 同一进程内的线程共享端口。
- **排查工具**：
  - `lsof -i :<port>`：查看端口占用。
  - `netstat -tulnp` 或 `ss -tlpn`：列出监听端口及进程。
  - `kill`：终止占用端口的进程。

### 6. 遇到端口相关问题
- 如果在项目中遇到端口相关问题（如 `Device or resource busy` 或端口冲突），可能是某个进程占用了端口。建议：
  1. 检查项目是否运行了监听端口的进程：
     ```bash
     lsof -i :<port_number>
     ```
     （替换 `<port_number>` 为你的项目使用的端口，如 8080）。
  2. 如果是调试或开发环境，检查是否多个实例尝试绑定同一端口。
  3. 如果需要释放端口，终止相关进程或使用 `SO_REUSEADDR`。

>### 解释“检查项目是否运行了监听端口的进程”
>
>“检查项目是否运行了监听端口的进程”是指确认你的程序（比如你在 `MovieAgent` 项目中运行的代码）是否有一个正在运行的进程绑定了某个网络端口（如 8080、80 等）。在 Linux 系统中，某些程序（如 Web 服务器、数据库、或你的项目）会“监听”特定端口以处理网络请求。如果端口被占用，可能会导致问题，比如无法启动新实例或报错“Address already in use”。
>
>结合你之前的问题（`mv` 报错“Device or resource busy”和询问端口占用），这句话的目的是建议你检查是否有进程占用了某个端口，可能是因为你的项目正在运行或有其他程序干扰。
>
>---
>
>### 具体含义和操作
>- **“监听端口的进程”**：
>  - 监听端口是指进程绑定了一个网络端口（如 TCP 80 端口用于 HTTP 请求），等待接收来自网络的连接或数据。
>  - 例如，你的项目可能是一个 Web 应用或服务，启动后会占用某个端口（比如 8080 或 5000）。
>
>- **为什么要检查**：
>  - 如果你的项目试图绑定一个已被其他进程占用的端口，会导致启动失败。
>  - 或者，某些进程可能占用了文件/目录（如你之前的 `mv` 问题），而检查端口占用可以排除网络相关的资源冲突。
>
>- **如何检查**：
>  使用 Linux 命令查看哪些进程正在监听特定端口，或者检查你的项目相关进程是否占用了端口。
>
>---
>
>### 检查端口占用的步骤
>以下是具体操作方法，帮你确认是否有进程（尤其是你的 `MovieAgent` 项目）正在监听端口：
>
>1. **使用 `lsof` 检查端口占用**：
>   - `lsof`（List Open Files）可以列出占用特定端口的进程。
>   - 命令：
>     ```bash
>     lsof -i :<port_number>
>     ```
>     - 替换 `<port_number>` 为你项目可能使用的端口（常见端口如 80、8080、5000、3000 等）。
>     - 示例：
>       ```bash
>       lsof -i :8080
>       ```
>       输出示例：
>       ```
>       COMMAND   PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAME
>       python  12345 xxxx  6u  IPv4  45678      0t0  TCP *:8080 (LISTEN)
>       ```
>       - 表示 PID 为 12345 的 Python 进程正在监听 8080 端口。
>       - 如果输出为空，说明该端口未被占用。
>
>2. **使用 `netstat` 或 `ss` 检查**：
>   - 替代方法，查看所有监听端口及其相关进程：
>     ```bash
>     netstat -tulnp | grep LISTEN
>     ```
>     或
>     ```bash
>     ss -tlpn
>     ```
>     - 输出示例：
>       ```
>       tcp   LISTEN   0   128   0.0.0.0:8080   0.0.0.0:*   users:(("python",pid=12345,fd=6))
>       ```
>       - 表示 8080 端口被 PID 12345 的 Python 进程占用。
>   - 如果你知道项目使用的端口，添加 `grep` 过滤：
>     ```bash
>     ss -tlpn | grep :8080
>     ```
>
>3. **检查项目相关进程**：
>   - 如果你不确定项目使用的端口，可以检查运行中的进程是否属于你的项目：
>     ```bash
>     ps aux | grep MovieAgent
>     ```
>     或
>     ```bash
>     ps aux | grep python
>     ```
>     - 假设你的项目是用 Python 写的，可能会看到类似：
>       ```
>       xxxx 12345  0.1  0.2 123456 7890 ?  S  18:00  0:01 python /path/to/MovieAgent/main.py
>       ```
>     - 记下 PID（12345），然后用 `lsof` 检查该进程的端口：
>       ```bash
>       lsof -p 12345 -a -i
>       ```
>       - `-a` 表示“与”逻辑，`-i` 限制只显示网络文件。

## 网络端口占用

**如果一个进程没有网络输入输出（即没有绑定或监听网络套接字），通常不会占用任何端口**。以下是详细解释，帮助你理解这个结论以及可能的例外情况：

### 1. **端口占用与网络输入输出的关系**
- **端口的定义**：
  - 端口是网络通信的逻辑端点，用于标识特定进程或服务（如 HTTP 使用 80 端口）。在 Linux 中，端口通过网络套接字（socket）与进程关联。
  - 只有当进程明确创建并绑定了一个网络套接字（通常通过 `bind()` 系统调用）到某个端口（例如 TCP 或 UDP 端口），才会占用该端口。

- **没有网络输入输出的进程**：
  - 如果一个进程不涉及网络通信（例如只进行本地文件操作、计算任务或与用户交互的命令行程序），它不会主动绑定任何网络端口，因此不会占用端口。
  - 例如：
    - 一个运行 `python script.py` 的脚本，如果只处理本地文件（如读写 CSV 文件），不会占用端口。
    - 像 `cat`、`grep` 或 `sort` 这样的命令行工具，通常不涉及网络，因此不占用端口。

- **检查是否占用端口**：
  - 你可以用以下命令确认进程是否占用端口：
    ```bash
    lsof -p <PID> -a -i
    ```
    - `<PID>` 是进程 ID，`-a` 表示“与”逻辑，`-i` 限制只显示网络相关信息。
    - 如果输出为空，说明该进程没有绑定任何端口。
  - 或者检查所有监听端口：
    ```bash
    ss -tlpn
    ```
    - 如果进程未出现在输出中，说明它没有监听端口。

### 2. **可能占用端口的情况**
即使一个进程看似没有“网络输入输出”，以下情况可能导致它占用端口：
- **隐式网络依赖**：
  - 某些进程可能通过库或框架间接使用网络。例如：
    - 一个 Python 程序使用了 `Flask` 或 `Django` 框架，启动了 Web 服务器，默认监听端口（如 5000 或 8000）。
    - 你的 `MovieAgent` 项目（结合你之前的上下文）可能包含服务器组件，即使你没有明确要求网络通信，代码可能自动监听端口。
  - **检查方法**：
    - 查看项目代码或配置文件，确认是否有类似 `app.run(port=5000)`（Flask）或 `server.listen(8080)` 的代码。
    - 运行：
      ```bash
      lsof -i -P | grep <process_name>
      ```
      （`-P` 显示端口号而不是服务名，如 8080 而非 http）

- **父进程或子进程绑定端口**：
  - 如果你的进程是由另一个进程（如 Web 服务器、容器）启动的，父进程可能绑定了端口。
  - 例如，`MovieAgent` 如果运行在 Docker 容器中，容器可能映射了端口。

- **系统服务或后台进程**：
  - 某些系统级进程可能在启动时绑定端口，但不一定有活跃的网络输入输出（例如监听但未收到连接）。
  - 示例：SSH 守护进程（`sshd`）监听 22 端口，即使当前没有连接。

### 3. 结合你的上下文（ `mv` 问题）
- **你的问题背景**：
  - 你提到 `mv` 命令报错“Device or resource busy”，可能与目录占用有关，而非端口占用。
  - 如果 `MovieAgent` 是一个本地程序（例如只处理视频文件或模型计算），它可能不涉及网络通信，因此不会占用端口。
  - 但如果 `MovieAgent` 包含服务器功能（例如 REST API、Web 界面），它可能默认监听某个端口（如 8080、5000）。

- **验证是否占用端口**：
  - 假设你知道 `MovieAgent` 的进程 ID（PID），运行：
    ```bash
    lsof -p <PID> -a -i
    ```
    - 如果输出为空，确认进程不占用端口。
  - 或者检查项目目录是否被进程占用（与 `mv` 问题相关）：
    ```bash
    lsof /home/huangguangji/workspace/Projects/Video-Factory/Video-Factory/models/MovieAgent
    ```
    - 如果有进程的 `cwd`（当前工作目录）或打开文件在该目录，说明目录被占用，导致 `mv` 失败。

- **解决 `mv` 问题**：
  - 如果确认 `MovieAgent` 不占用端口，但目录被占用：
    1. 退出当前目录：
       ```bash
       cd ..
       ```
    2. 终止占用目录的进程（用 `lsof` 找到 PID）：
       ```bash
       kill -9 <PID>
       ```
    3. 重试移动：
       ```bash
       mv /home/huangguangji/workspace/Projects/Video-Factory/Video-Factory/models/MovieAgent /data/hdd2/huangguangji/workspace/Projects/MA
       ```

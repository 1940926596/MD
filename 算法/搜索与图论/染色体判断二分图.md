# 染色体判断二分图

## 二分图

**二分图**（Bipartite Graph）是图论中的一种特殊图结构。它具有以下主要特征：

### 1. **定义**

一个图 $G = (V, E)$ 是二分图，如果其顶点集 $V$ 可以被划分成两个不相交的子集 $U$ 和 $W$，使得图中的每条边都仅连接 $U$ 和 $W$ 中的顶点，而不连接同一个子集中的顶点。换句话说，图中的每条边都跨越这两个子集。

### 2. **性质**

- **顶点划分**：图 $G$ 的顶点集 $V$ 可以被分为两个子集 $U$ 和 $W$，使得 $U \cap W = \emptyset$，并且任意一条边 $(u, w) \in E$ 中的 $u \in U$ 和 $w \in W$。
- **无奇环**：一个图是二分图，当且仅当它不包含长度为奇数的环（即图中所有的环长度都是偶数）。这是因为在二分图中，从一个顶点出发，经过偶数条边回到起点的路径是允许的，但经过奇数条边回到起点的路径是不允许的。
- **图染色**：可以使用两种颜色对二分图的顶点进行染色，使得相邻的两个顶点具有不同的颜色。这种染色方法的复杂度为 $O(n)$，其中 $n$ 是图中顶点的数量。

### 3. **应用**

二分图在许多实际问题中都有应用：

- **任务分配**：例如，分配任务给工人，每个工人只适合某些任务，目标是找到最优分配方案。
- **网络流**：在最大流问题中，流网络可以被建模为二分图，特别是在二分图的最大匹配问题中。
- **婚配问题**：例如，匹配男性和女性的配对问题，每个男性和女性之间的边表示他们的匹配可能性。

## 算法原理

### 1. **图的表示**

在算法中，图使用邻接表表示：
- `h[i]`：顶点 `i` 的邻接链表的头指针。
- `e[i]`：表示边的终点。
- `ne[i]`：表示下一条边的索引。

### 2. **染色操作**

染色操作的目标是使用两种颜色（通常用 1 和 2 表示）对图的所有顶点进行染色，使得相邻的两个顶点颜色不同。如果图能够成功染色，则该图是二分图，否则不是。

### 3. **DFS 算法**

通过深度优先搜索（DFS）进行染色：
- 从未染色的顶点开始，尝试将其染成颜色 1。
- 对于当前顶点的每个邻接点，如果该邻接点未染色，则将其染成另一个颜色，并递归进行染色。
- 如果邻接点已染色，检查颜色是否与当前顶点不同。如果相同，则说明图不是二分图，返回 `false`。

### 4. **判断图是否为二分图**

对图中的每个顶点进行 DFS 操作，如果所有 DFS 操作都成功，则图是二分图，否则不是。

## 代码实现

```c++
#include <cstring>
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010, M = 200010;

int n, m;
int h[N], e[M], ne[M], idx;
int color[N];

void add(int a, int b)
{
    e[idx] = b, ne[idx] = h[a], h[a] = idx ++ ;
}

bool dfs(int u, int c)
{
    color[u] = c;

    for (int i = h[u]; i != -1; i = ne[i])
    {
        int j = e[i];
        if (!color[j])
        {
            if (!dfs(j, 3 - c)) return false;
        }
        else if (color[j] == c) return false;
    }
    
    return true;
}

int main()
{
    scanf("%d%d", &n, &m);

    memset(h, -1, sizeof h);
    
    while (m -- )
    {
        int a, b;
        scanf("%d%d", &a, &b);
        add(a, b), add(b, a);
    }
    
    bool flag = true;
    for (int i = 1; i <= n; i ++ )
        if (!color[i])
        {
            if (!dfs(i, 1))
            {
                flag = false;
                break;
            }
        }
    
    if (flag) puts("Yes");
    else puts("No");
    
    return 0;
}
```
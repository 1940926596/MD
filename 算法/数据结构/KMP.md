# KMP 算法

```cpp
#include <iostream>

using namespace std;

const int N = 100010, M = 1000010;

int n, m;
int ne[N];
char s[M], p[N];

int main()
{
    cin >> n >> p + 1 >> m >> s + 1;
    
    //求next数组的过程
    //next数组是最大匹配前缀和，后缀和的位数

    for (int i = 2, j = 0; i <= n; i ++ )
    {
        while (j && p[i] != p[j + 1]) j = ne[j];
        if (p[i] == p[j + 1]) j ++ ;
        ne[i] = j;
    }

    //KMP过程
    for (int i = 1, j = 0; i <= m; i ++ )
    {
        while (j && s[i] != p[j + 1]) j = ne[j];
        if (s[i] == p[j + 1]) j ++ ;
        if (j == n)
        {
            printf("%d ", i - n);
            j = ne[j];
        }
    }

    return 0;
}
```

**KMP 算法**（Knuth-Morris-Pratt 算法）是一种用于字符串匹配的高效算法。它通过利用已经匹配过的部分来优化匹配过程，从而避免重复计算。下面是对 KMP 算法的详细解释，包括其核心数据结构 `next` 数组的计算和匹配过程。

## 1. 算法背景

KMP 算法用于在一个主字符串 `s` 中查找一个模式字符串 `p` 的所有出现位置。其主要优点是时间复杂度为 $O(n + m)$，其中 $n$ 是主字符串的长度，$m$ 是模式字符串的长度。这比传统的暴力匹配算法要高效得多。

## 2. next 数组的计算

`next` 数组（或称 `pi` 数组）是 KMP 算法的关键部分，用于记录模式字符串 `p` 中每个位置的部分匹配信息。

### 2.1 next 数组的定义

`next[i]` 表示模式字符串 `p` 中以第 `i` 个字符结尾的最长前缀的长度，这个前缀也是该前缀的后缀。例如，如果 `p` 是 "ABABC"，那么 `next` 数组记录的是每个位置的最长相等前后缀长度。

### 2.2 计算过程

```cpp
for (int i = 2, j = 0; i <= n; i ++ )
{
    while (j && p[i] != p[j + 1]) j = ne[j];
    if (p[i] == p[j + 1]) j ++ ;
    ne[i] = j;
}
```


- **初始化**：从 `i = 2` 开始计算 `next` 数组，`j` 初始化为 0。
- **比较**：如果当前字符 `p[i]` 不匹配前缀末尾字符 `p[j + 1]`，则通过 `j = ne[j]` 更新 `j`，继续尝试更短的前缀。
- **匹配**：如果字符匹配，则 `j` 增加 1，表示找到更长的匹配前缀。
- **更新**：将计算得到的 `j` 存储到 `ne[i]` 中。

## 3. KMP 字符串匹配过程

### 3.1 匹配过程

```cpp
for (int i = 1, j = 0; i <= m; i ++ )
{
    while (j && s[i] != p[j + 1]) j = ne[j];
    if (s[i] == p[j + 1]) j ++ ;
    if (j == n)
    {
        printf("%d ", i - n);
        j = ne[j];
    }
}
```

- **初始化**：从 `i = 1` 和 `j = 0` 开始匹配。
- **比较**：如果当前字符 `s[i]` 不匹配模式字符串的当前字符 `p[j + 1]`，则更新 `j`，尝试更短的前缀。
- **匹配**：如果字符匹配，则 `j` 增加 1，表示模式字符串的前缀匹配成功。
- **完整匹配**：当 `j` 达到模式字符串的长度 `n` 时，表示匹配成功，此时 `i - n` 是匹配的位置（0-based index）。
- **更新**：匹配完成后，通过 `j = ne[j]` 更新 `j`，继续查找下一个可能的匹配。

## 4. 示例

假设模式字符串 `p = "ABAB"` 和主字符串 `s = "ABABABABAB"`，计算 `next` 数组和进行匹配的过程如下：

1. **计算 `next` 数组**：
   - `p = "ABAB"`
   - `next = [0, 0, 1, 2]`（详细计算见代码注释部分）

2. **字符串匹配**：
   - 通过 KMP 算法在 `s` 中查找 `p`，得到匹配位置。

## 5. 总结

KMP 算法通过 `next` 数组优化了字符串匹配过程，避免了重复计算，实现了高效的匹配。计算 `next` 数组的时间复杂度为 $O(m)$，匹配过程的时间复杂度为 $O(n)$，总时间复杂度为 $O(n + m)$。


## fork

在 C++ 中，`fork()` 是一个用于创建进程的系统调用，常用于 Linux 和 Unix 系统中。它来自于 `<unistd.h>` 头文件。

**`fork()` 的作用**

`fork()` 用于创建一个新的进程，称为 **子进程 (child process)**。该函数会在父进程和子进程中各返回一次，并且这两个进程会从 `fork()` 调用点之后的代码继续执行。

**返回值解释**

`fork()` 的返回值决定了程序的运行逻辑：

- **父进程中返回子进程的 PID（进程 ID）**（一个正整数）。
- **子进程中返回 0**，表示此进程是子进程。
- **返回 -1** 表示进程创建失败。

**示例代码：**

```cpp
#include <iostream>
#include <unistd.h>

int main() {
    pid_t pid = fork();  // 创建进程
    
    if (pid > 0) {
        // 父进程执行
        std::cout << "我是父进程，子进程的 PID 是: " << pid << std::endl;
    } else if (pid == 0) {
        // 子进程执行
        std::cout << "我是子进程，PID 是: " << getpid() << std::endl;
    } else {
        // 错误处理
        std::cerr << "进程创建失败！" << std::endl;
    }
    return 0;
}
```

**运行结果示例：**

```
我是父进程，子进程的 PID 是: 12345  
我是子进程，PID 是: 12345  
```

**注意事项：**

1. **代码执行顺序不确定：** 父进程和子进程可能按任意顺序执行。
2. **资源共享与隔离：** 子进程继承父进程的大部分资源（如文件描述符等），但有独立的内存空间。
3. **创建失败原因：** 可能由于系统资源耗尽或超出进程数限制。

## 进程管理

**深入了解 `fork()` 与进程管理**

`fork()` 是 Unix/Linux 系统中的核心系统调用之一，主要用于 **进程创建**。为了全面理解，下面将详细解释相关的进程管理机制，包括进程生命周期、内存结构、常用系统调用，以及 `fork()` 的具体行为。

### **1. 进程生命周期**

**父进程 → `fork()` → 子进程**

- **父进程 (Parent Process)：** 调用 `fork()` 并继续运行。
- **子进程 (Child Process)：** `fork()` 成功后产生的进程，是父进程的副本。

**进程状态：**

- **运行中 (Running):** 正在使用 CPU。
- **就绪 (Ready):** 等待 CPU 调度。
- **等待 (Waiting):** 等待 I/O 或事件发生。
- **终止 (Terminated):** 进程完成执行或被杀死。

### **2. `fork()` 的执行行为**

**父子进程共享与独立的资源：**

| 资源                   | 继承/复制行为             |
| ---------------------- | ------------------------- |
| 内存（堆、栈、数据段） | **独立的副本** (COW 机制) |
| 文件描述符 (FD)        | **共享**                  |
| 环境变量               | **继承**                  |
| 信号处理程序           | **继承**                  |
| 进程 ID (PID)          | **不同** (唯一)           |

------

### **3. 常见系统调用与 `fork()` 搭配使用**

#### 1. **`exec()` 系列函数**

用于运行一个新程序，常见函数：

- `execl()` / `execvp()` / `execv()` / `execve()`

示例：子进程运行另一个程序：

```cpp
#include <unistd.h>
#include <iostream>
int main() {
    pid_t pid = fork();

    if (pid == 0) {
        execl("/bin/ls", "ls", "-l", nullptr);  // 执行新程序
    } else if (pid > 0) {
        std::cout << "父进程，子进程 PID: " << pid << std::endl;
    } else {
        std::cerr << "fork 失败!" << std::endl;
    }
    return 0;
}
```

------

#### 2. **`wait()` / `waitpid()`**

用于让父进程等待子进程完成。

```cpp
#include <sys/wait.h>
#include <unistd.h>
#include <iostream>

int main() {
    pid_t pid = fork();
    
    if (pid == 0) {
        std::cout << "子进程正在运行..." << std::endl;
        sleep(2);  // 模拟工作
        std::cout << "子进程结束。" << std::endl;
    } else if (pid > 0) {
        int status;
        waitpid(pid, &status, 0);  // 等待子进程完成
        std::cout << "父进程检测到子进程结束。" << std::endl;
    }
    return 0;
}
```

------

#### 3. **`getpid()` / `getppid()`**

- `getpid()` 获取当前进程的 PID。
- `getppid()` 获取父进程的 PID。

------

### **4. 重要概念解析**

#### **1. COW (Copy-On-Write) 机制**

- 在 `fork()` 后，父子进程共享同一内存区域，但当其中一个修改时，操作系统会复制该内存区域，确保独立性。
- 优点：**节省内存，提升性能。**

**COW 在 `fork()` 中的应用**

**常规行为（无 COW）**：

- 调用 `fork()` 时，操作系统需要 **复制整个父进程的内存**（包括堆、栈和全局数据段），用于子进程。
- 这会导致 **内存开销巨大**，尤其在大型应用程序中。

**启用 COW 的行为**：

- 操作系统不会立即复制内存。
- 父子进程 **共享内存页**（通常是只读）。
- **只有在写操作时**，内核才会复制相关内存页，并将该页标记为“已修改”。

------

#### **2. 僵尸进程 (Zombie Process)**

- 子进程终止，但父进程未调用 `wait()`，导致子进程残留在进程表中，占用资源。

**解决方法：**

- 调用 `wait()` 或 `waitpid()` 清理。
- 使用信号处理函数 `SIGCHLD` 自动回收。

示例：自动处理子进程终止信号：

```cpp
#include <signal.h>
#include <sys/wait.h>
#include <unistd.h>
#include <iostream>

void handle_signal(int sig) {
    while (waitpid(-1, nullptr, WNOHANG) > 0);  // 非阻塞清理子进程
}

int main() {
    signal(SIGCHLD, handle_signal);  // 捕获子进程终止信号

    pid_t pid = fork();
    if (pid == 0) {
        std::cout << "子进程运行中..." << std::endl;
        sleep(2);  // 模拟子进程工作
        std::cout << "子进程完成。" << std::endl;
        _exit(0);  // 正常退出子进程
    } else if (pid > 0) {
        std::cout << "父进程继续执行..." << std::endl;
        sleep(5);  // 父进程忙于其他任务
        std::cout << "父进程完成。" << std::endl;
    }
    return 0;
}
```

------

#### **3. 孤儿进程 (Orphan Process)**

- 当父进程终止，而子进程继续运行时，子进程成为孤儿进程，**由 `init` (PID 1) 进程收养。**

------

### **5. `fork()` 执行过程总结图解**

```
父进程 (PID: A)
     |
     |---- 调用 `fork()`
     |
+---------------------------+
|          内核执行           |
+---------------------------+
     |
     |----> 子进程 (PID: B)
     |       |---- 返回值 = 0 (子进程执行)
     |
     |----> 父进程 (PID: A)
             |---- 返回值 = B (子进程 PID)
```

------

### **重要注意事项：**

1. **资源分离：** 确保在父子进程中正确管理内存、文件等资源。
2. **进程终止检测：** 使用 `wait()` 避免僵尸进程。
3. **多进程通信：** 使用管道、共享内存、信号等机制。
4. **系统限制：** 每个操作系统对最大进程数和内存消耗有硬性限制。
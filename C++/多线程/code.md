## 多线程
```c++
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

std::mutex mtx;   // 互斥锁，用于保护临界区
int counter = 0;   // 临界资源
std::condition_variable cv;
bool stop= false;

void increment(int i) {
    // 临界区：修改 counter 的代码
    std::unique_lock<std::mutex> lock(mtx);
    std::cout<<i<<"+++++++"<<std::endl;
    cv.wait(lock,[]{return stop;}); // 释放锁并等待通知
    ++counter;
    std::cout<<i<<"-------"<<std::endl;
    std::cout<<i<<"-------"<<std::endl;
    std::cout<<i<<"-------"<<std::endl;
    std::cout<<i<<"-------"<<std::endl;
    std::cout << counter << std::endl;
}

int main() {
    // 创建多个线程，模拟并发访问
    std::thread t1(increment, 1);
    std::thread t2(increment, 2);
    std::thread t3(increment, 3);


    // 通过 notify_all 唤醒所有等待的线程
    //std::this_thread::sleep_for(std::chrono::milliseconds(100)); // 确保所有线程都开始等待

    stop= true;
//    cv.notify_all();  // 唤醒所有线程

    t1.join();
    t2.join();
    t3.join();

    std::cout << "Final counter value: " << counter << std::endl;

    return 0;
}

```

在这段代码中，`std::condition_variable` 被用来使得线程在修改共享资源 `counter` 时能通过条件变量等待一个通知 (`cv.wait(lock, []{return stop;})`)。但即使没有显式调用 `notify_one` 或 `notify_all`，程序仍然能够“完美运行”，原因如下：

### 1. cv.wait 的阻塞与唤醒

`cv.wait(lock, []{return stop;})` 会使线程进入等待状态，并且释放 `mtx` 锁，直到条件满足（即 `stop == true`）。而且，当条件变量被触发时，线程会自动重新获得 `mtx` 锁并继续执行。

### 2. stop 变量的变化

在 `main` 函数中，你将 `stop` 变量设置为 `true`（即 `stop = true;`）。这个修改是在所有线程启动后（即线程进入等待状态之前）进行的。

在这段代码中，由于 `stop` 在 `main` 线程中已经被设置为 `true`，所有的线程在 `cv.wait` 中都能看到这个条件已经满足。因此，线程在等待时会立即唤醒并继续执行。

### 3. 没有显式通知的原因

实际上，`std::condition_variable` 的作用是让线程在条件不满足时进行等待，直到条件发生变化。通常，你需要显式调用 `notify_one` 或 `notify_all` 来通知等待的线程条件已经满足，进而唤醒它们。

但是，`cv.wait` 也支持直接检查传入的条件（在这里就是 `stop == true`）。如果条件已经是 `true`，线程会立即继续执行，而不需要等待通知。因此，虽然没有显式调用 `notify_one` 或 `notify_all`，但 `stop` 变量已经被设置为 `true`，这使得等待的线程会立刻重新获得锁并继续执行。

## C++中实现线程池

在C++中实现线程池是为了提高程序在处理多任务时的效率和性能。**线程池通过预先创建一定数量的线程，并将它们保存在池中**，以便重复使用，从而避免了频繁创建和销毁线程的开销。线程池的核心组成部分包括工作队列、任务队列、线程池本身以及回调函数。

线程池的关键组件

**工作队列（Worker Queue）**：工作队列负责存储线程池中的工作线程。每个工作线程都有一个线程ID，一个标志位来决定线程是否应该终止，以及一个标志位来表示线程是否正在工作。此外，每个工作线程都知道自己属于哪个线程池。

**任务队列（Task Queue）**：任务队列存储待处理的任务。每个任务都是一个函数，它有自己的参数。任务队列是生产者-消费者模型的一个实例，需要互斥锁和条件变量来同步任务的添加和获取。

**线程池本身**：线程池管理工作队列和任务队列，使用互斥锁和条件变量来同步对任务队列的访问，并提供接口供用户提交任务。

**回调函数**：回调函数是线程创建时执行的函数，它决定了工作线程应该执行的操作。在C++中，回调函数通常是一个静态成员函数，以避免自动添加*this*指针。

==回调函数就是一个参数，将这个函数作为参数传到另一个函数里面，当那个函数执行完之后，再执行传进去的这个函数。这个过程就叫做回调。==

```c++
#ifndef THREAD_POOL_H
#define THREAD_POOL_H

#include <thread>
#include <queue>
#include <vector>
#include <functional>
#include <mutex>
#include <condition_variable>

class ThreadPool {
private:
    std::vector<std::thread> workers;                  // 存储线程对象的向量
    std::queue<std::function<void()>> tasks;           // 存储任务的队列
    std::mutex queue_mutex;                            // 保护任务队列的互斥锁
    std::condition_variable condition;                 // 条件变量，用于线程同步
    bool stop;                                         // 标志位，用于停止线程池

public:
    explicit ThreadPool(size_t threads) : stop(false) {
        for (size_t i = 0; i < threads; ++i) {
            workers.emplace_back([this] {
                while (true) {
                    std::function<void()> task;

                    {
                        std::unique_lock<std::mutex> lock(this->queue_mutex);
                        this->condition.wait(lock, [this] { return this->stop || !this->tasks.empty(); });

                        if (this->stop && this->tasks.empty()) {
                            return;
                        }

                        task = std::move(this->tasks.front());
                        this->tasks.pop();
                    }

                    task();
                }
            });
        }
    }

    template <class F>
    void enqueue(F &&f) {
        {
            std::unique_lock<std::mutex> lock(queue_mutex);
            tasks.emplace(std::forward<F>(f));
        }
        condition.notify_one();
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(queue_mutex);
            stop = true;
        }
        condition.notify_all();
        for (std::thread &worker : workers) {
            worker.join();
        }
    }
};

#endif // THREAD_POOL_H

```

在多线程编程中，**使用线程池**和**不使用线程池**（即直接创建线程）有几个重要的区别，涉及到性能、资源管理、程序复杂度等方面。以下是这两者的对比：

### 1. **资源管理**

不使用线程池：

- **线程的创建和销毁开销**：每次需要并行执行任务时，都必须创建一个新线程。当任务完成后，线程会被销毁。线程的创建和销毁是非常昂贵的操作，尤其在任务频繁且短暂时，开销会非常大。
- **资源消耗**：每个线程都会消耗操作系统的资源（如内存、CPU 时间等），当创建大量线程时，可能会导致系统资源耗尽，进而影响程序的性能。

使用线程池：

- **线程复用**：线程池会预先创建一定数量的线程，线程池中的线程在任务完成后不会销毁，而是等待并复用来执行新的任务。这样就避免了频繁创建和销毁线程的开销。
- **线程数量受控**：线程池通常会限制最大线程数，以防系统资源被耗尽。如果任务数过多，超出最大线程数，线程池会将任务排入队列等待处理，而不是创建新的线程。

**总结**：线程池通过复用线程，显著减少了线程创建和销毁的开销，避免了系统资源的过度消耗。

### 2. **性能**

不使用线程池：

- **频繁创建/销毁线程的性能损失**：每个任务都要创建一个新线程，并在任务完成后销毁线程。如果任务执行时间较短，频繁的线程创建和销毁会占用大量 CPU 和内存资源，导致性能下降。
- **线程调度开销**：如果系统中有很多线程，操作系统的线程调度可能会变得复杂，可能导致线程切换的开销增大。

使用线程池：

- **减少线程切换**：线程池中的线程是预先创建并复用的，任务执行时线程的上下文切换开销较小。
- **更高的吞吐量**：由于避免了频繁的线程创建和销毁，线程池通常可以提高任务的执行效率，尤其在高频任务执行的场景下。

**总结**：线程池提高了任务执行的吞吐量，尤其适用于任务频繁且生命周期短的场景。

### 3. **程序设计复杂度**

不使用线程池：

- **手动管理线程**：每个任务都需要手动创建一个线程并管理其生命周期，程序员需要确保每个线程都能够正确地启动、执行和终止。这使得代码更加复杂，尤其是在需要管理大量线程时。
- **同步问题**：多个线程之间需要协调和同步，这增加了程序的复杂度。如果没有适当的锁和同步机制，可能导致数据竞争、死锁等问题。

使用线程池：

- **简化线程管理**：线程池封装了线程的创建、销毁和任务调度的细节，程序员只需要关注任务的提交和结果，而无需关心线程的管理。
- **减少同步问题**：由于线程池管理线程的复用，程序员更容易设计线程安全的任务调度。任务本身仍然可能需要同步，但线程池本身的线程管理减少了复杂度。

**总结**：使用线程池可以显著减少程序中的线程管理复杂度，程序员不需要手动管理每个线程的生命周期。

### 4. **可伸缩性**

不使用线程池：

- **线程数不易控制**：如果任务数量不确定，或者任务的执行时间不均匀，可能会导致线程数量过多或过少。在负载高时，可能创建过多线程，导致系统资源耗尽；在负载低时，线程可能闲置，造成资源浪费。
- **系统负担**：操作系统对大量线程的管理有一定的限制，超过系统能够处理的线程数可能导致系统崩溃或性能急剧下降。

使用线程池：

- **线程数量受控**：线程池通常会设置最大线程数，避免线程数过多导致资源耗尽。可以根据任务的负载情况，灵活调整线程池的大小。
- **提高系统可伸缩性**：线程池能够根据任务的队列长度和系统资源动态调整线程池的大小，以应对负载的变化。

**总结**：线程池通过控制线程数和任务调度，使得系统在不同负载下能够更加灵活和高效地扩展。

### 5. **任务调度与优先级**

不使用线程池：

- **任务调度较复杂**：每个线程的执行顺序和调度完全由操作系统的线程调度器控制。没有统一的任务队列，也就无法实现任务优先级的控制和调度。
- **容易丢失任务**：如果某些线程完成后没有及时清理，可能导致任务丢失或无法及时执行。

使用线程池：

- **任务队列**：线程池通常会使用任务队列来存储待执行的任务，任务的提交和执行有明确的顺序，避免了丢失任务的问题。
- **优先级控制**：线程池可以通过优先级队列（如 `std::priority_queue`）等机制对任务进行优先级调度，确保重要任务优先执行。

**总结**：线程池提供了更好的任务调度机制，可以通过任务队列和优先级调度来控制任务的执行顺序。

### 6. **错误处理**

不使用线程池：

- **线程中的错误处理**：每个线程的错误需要单独捕获和处理。没有集中管理，可能导致程序在多个线程中错误处理不一致。

使用线程池：

- **集中错误管理**：可以在线程池内部统一处理任务执行中的异常。例如，在任务执行过程中捕获异常并记录错误，而不会导致整个程序崩溃。

**总结**：线程池可以通过集中管理异常，提供更强的错误处理能力。

------

### 总结：使用线程池 vs 不使用线程池

| 特性           | 不使用线程池                             | 使用线程池                       |
| -------------- | ---------------------------------------- | -------------------------------- |
| **线程管理**   | 需要手动创建、销毁线程                   | 线程池自动管理线程的创建和销毁   |
| **性能**       | 频繁的线程创建和销毁影响性能             | 线程复用，减少线程创建销毁的开销 |
| **程序复杂度** | 需要手动管理线程的生命周期               | 简化线程管理和任务调度           |
| **资源消耗**   | 创建大量线程时消耗系统资源               | 线程池中的线程复用，资源消耗更低 |
| **系统伸缩性** | 线程数不容易控制，可能导致资源耗尽或浪费 | 可以动态调整线程数，提高可伸缩性 |
| **任务调度**   | 无法实现任务优先级控制                   | 可以实现任务优先级调度           |
| **错误处理**   | 每个线程需要单独处理错误                 | 线程池统一管理错误               |

**结论**：在任务数量较多且执行时间较短、频繁时，使用线程池可以显著提高性能，简化程序设计，并有效管理系统资源。对于简单的、任务较少且执行时间较长的程序，不使用线程池可能更直接，线程池的管理开销相对较大。
